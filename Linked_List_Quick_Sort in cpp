#include <iostream> 
using namespace std; 

struct Node 
{ 
	int data; 
	struct Node *next; 
}; 

void push(struct Node** head_ref, int new_data) 
{ 
	struct Node* new_node = new Node; 

	// put in the data 
	new_node->data = new_data; 

	// link the old list off the new node 
	new_node->next = (*head_ref); 

	// move the head to point to the new node 
	(*head_ref) = new_node; 
} 

// print linked list 
void printList(struct Node *node) 
{ 
	while (node != NULL) 
	{ 
		printf("%d ", node->data); 
		node = node->next; 
	} 
	printf("\n"); 
} 

// Returns the last node
struct Node *getTail(struct Node *cur) 
{ 
	while (cur != NULL && cur->next != NULL) 
		cur = cur->next; 
	return cur; 
} 

struct Node *partition(struct Node *head, struct Node *end, struct Node **newHead, struct Node **newEnd) 
{ 
	struct Node *pivot = end; 
	struct Node *prev = NULL, *cur = head, *tail = pivot; 

	while (cur != pivot) 
	{ 
		if (cur->data < pivot->data) 
		{ 
			// First node that has a value less than the pivot - becomes the new head

			if ((*newHead) == NULL) 
				(*newHead) = cur; 

			prev = cur; 
			cur = cur->next; 
		} 
		else // If cur node is greater than pivot 
		{ 
			if (prev) 
				prev->next = cur->next; 
			struct Node *tmp = cur->next; 
			cur->next = NULL; 
			tail->next = cur; 
			tail = cur; 
			cur = tmp; 
		} 
	} 

	// If the pivot data is the smallest element in the current list, pivot becomes the head 
	if ((*newHead) == NULL) 
		(*newHead) = pivot; 

	// Update newEnd to the current last node 
	(*newEnd) = tail; 

	// Return the pivot node 
	return pivot; 
} 


//here the sorting happens 
struct Node *quickSortRecur(struct Node *head, struct Node *end) 
{ 

	if (!head || head == end) 
		return head; 

	Node *newHead = NULL, *newEnd = NULL; 

	// Partition the list, newHead and newEnd will be updated by the partition function

	struct Node *pivot = partition(head, end, &newHead, &newEnd); 

	// If pivot is the smallest element - no need to recur 
	if (newHead != pivot) 
	{ 
		// Set the node before the pivot node as NULL 
		struct Node *tmp = newHead; 
		while (tmp->next != pivot) 
			tmp = tmp->next; 
		tmp->next = NULL; 

		// Recur for the list before pivot 
		newHead = quickSortRecur(newHead, tmp); 

		// Change next of last node of the left half to pivot 
		tmp = getTail(newHead); 
		tmp->next = pivot; 
	} 

	// Recur for the list after the pivot element 
	pivot->next = quickSortRecur(pivot->next, newEnd); 

	return newHead; 
} 


void quickSort(struct Node **headRef) 
{ 
	(*headRef) = quickSortRecur(*headRef, getTail(*headRef)); 
	return; 
} 

int main() 
{ 
	struct Node *a = NULL; 
	push(&a, 5); 
	push(&a, 20); 
	push(&a, 4); 
	push(&a, 3); 
	push(&a, 30); 

	cout << "Linked List before sorting \n"; 
	printList(a); 

	quickSort(&a); 

	cout << "Linked List after sorting \n"; 
	printList(a); 

	return 0; 
} 
